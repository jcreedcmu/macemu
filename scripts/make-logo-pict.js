const fs = require('fs');
const path = require('path');
const {rezOfBytes} = require('./rez-utils');

console.log(`/*****************
* This file is generated by scripts/make-logo-pict.js, edits may be lost
*****************/`);

const boundRect = {top: 0, left: 0, right: 515, bottom: 431};

function rectBytes(rect) {
  return [
	 ...wordBytes(rect.top),
	 ...wordBytes(rect.left),
	 ...wordBytes(rect.bottom),
	 ...wordBytes(rect.right),
  ];
}

function rectRegionBytes(rect) {
  return [
	 ...wordBytes(10),
	 ...wordBytes(rect.top),
	 ...wordBytes(rect.left),
	 ...wordBytes(rect.bottom),
	 ...wordBytes(rect.right),
  ];
}

function wordBytes(word) {
  return [0xff & (word >> 8), 0xff & word];
}

function longBytes(word) {
  return [0xff & (word >> 24), 0xff & (word >> 16), 0xff & (word >> 8), 0xff & word];
}

const header = [
  0x00, 0x11, 0x02, 0xff, 0x0c, 0x00, 0xff, 0xfe, // required specific header bytes
  0x00, 0x00, // reserved
  0x00, 0x48, 0x00, 0x00, // horizontal resolution 72dpi
  0x00, 0x48, 0x00, 0x00, // vertical resolution 72dpi
  ...rectBytes(boundRect),
  0x00, 0x00, // reserved
];

function words(string) {
  return string.split(/\s+/).filter(x => x.length).flatMap(x => wordBytes(parseInt(x, 16)));
}

function fgColor(r, g, b) {
  return [...wordBytes(0x001a), r, r, g, g, b, b];
}

function bgColor(r, g, b) {
  return [...wordBytes(0x001b), r, r, g, g, b, b];
}

function fgPat(...patBytes) { // expects 8 bytes
  return [...fgColor(0,0,0), ...bgColor(0xff, 0xff, 0xff), ...wordBytes(0x000a), ...patBytes];
}

function clipRect(rect) {
  return [...wordBytes(0x0001), ...rectRegionBytes(rect)];
}

function fillRect(rect) {
  return [...wordBytes(0x0034), ...rectBytes(rect)];
}

function polyBytes(poly) {
  const bdrect = {
	 top: Math.min(...poly.map(p => p.y)),
	 left: Math.min(...poly.map(p => p.x)),
	 bottom: Math.max(...poly.map(p => p.y)),
	 right: Math.max(...poly.map(p => p.x)),
  };
  return [...wordBytes(2 + 8 + 4 * poly.length),
			 ...rectBytes(bdrect),
			 ...poly.flatMap(pt => {return [...wordBytes(pt.y), ...wordBytes(pt.x)]; })];
}

function fillPoly(poly) {
  return [...wordBytes(0x0074), ...polyBytes(poly)];
}

function endPict() {
 return wordBytes(0x00FF);
}

function defHilite() {
  return wordBytes(0x001e);
}

const layer1 = JSON.parse(fs.readFileSync(path.join(__dirname, '../assets/twelf-logo-layer-1.json'), 'utf8'));
const layer2 = JSON.parse(fs.readFileSync(path.join(__dirname, '../assets/twelf-logo-layer-2.json'), 'utf8'));

function convertPts(cs) {
  return cs.map(p => ({x:p[0], y:boundRect.bottom - p[1]}));
}

function getPolys(layer, ix) {
  return layer.features[ix].geometry.coordinates.map((cs, ix) => ({
	 polarity: ix == 0,
	 ps: cs.map(p => ({x:p[0], y:p[1]})),
  }));
}

function getPolyData(config) {
  const polyData = [];

  // legs

  polyData.push(...fgPat(0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff));
  for (const feature of layer1.features.slice(6,8)) {
	 polyData.push(...fgColor(0, 0, 0));
	 polyData.push(...fillPoly(convertPts(feature.geometry.coordinates[0])));
	 polyData.push(...fgColor(0xff, 0xff, 0xff));
	 for (const cutout of feature.geometry.coordinates.slice(1)) {
		polyData.push(...fillPoly(convertPts(cutout)));
	 }
  }

  // hat and shorts

  polyData.push(...config.darkGreen);
  polyData.push(...fillPoly(convertPts(layer2.features[0].geometry.coordinates[0])));
  polyData.push(...fillPoly(convertPts(layer2.features[1].geometry.coordinates[0])));
  polyData.push(...config.lightGreen);
  polyData.push(...fillPoly(convertPts(layer2.features[0].geometry.coordinates[1])));
  polyData.push(...fillPoly(convertPts(layer2.features[1].geometry.coordinates[1])));
  polyData.push(...fgColor(0xff, 0xff, 0xff));
  polyData.push(...fillPoly(convertPts(layer2.features[0].geometry.coordinates[2])));

  // sign and letters

  polyData.push(...fgPat(0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff));
  for (const feature of layer1.features.slice(0,6)) {
	 polyData.push(...fgColor(0, 0, 0));
	 polyData.push(...fillPoly(convertPts(feature.geometry.coordinates[0])));
	 polyData.push(...fgColor(0xff, 0xff, 0xff));
	 for (const cutout of feature.geometry.coordinates.slice(1)) {
		polyData.push(...fillPoly(convertPts(cutout)));
	 }
  }
  return polyData;
}

function imageBytes(config) {
  const image = [
	 ...defHilite(),
	 ...clipRect(boundRect),

	 ...getPolyData(config),

	 ...endPict(),
  ]

  const imageWithHeader = [
	 ...header,
	 ...image,
  ];

  const imageRezBytes = [
	 ...wordBytes(
		2 + /* length of this length field */
		8 + /* length of bounding Rect */
		imageWithHeader.length),
	 ...rectBytes(boundRect),
	 ...imageWithHeader
  ];

  return imageRezBytes;
}

const configColor = {
  lightGreen: fgColor(0x66, 0x99, 0x66),
  darkGreen: fgColor(0x0a, 0x30, 0x09),
};

const configBw = {
  lightGreen: fgPat(0x55, 0xaa, 0x55, 0xaa, 0x55, 0xaa, 0x55, 0xaa),
  darkGreen: fgPat(0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff),
};

console.log(`
data 'PICT' (rAboutPict, purgeable) {
  ${rezOfBytes(imageBytes(configColor)).replace(/ \$/g, '\n $')}
};

data 'PICT' (rAboutPict+1, purgeable) {
  ${rezOfBytes(imageBytes(configBw)).replace(/ \$/g, '\n $')}
};
`);
