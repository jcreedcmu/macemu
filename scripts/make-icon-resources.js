// make-icon-resources.js
//
// Generates an .r file (on stdout) from icon files assumed to exist
// in text PPM format in /tmp. See the definition of `iconSources`
// below for configuration details.

const fs = require('fs');
const palette = require('./palette');

console.log(`/*****************
* This file is generated by scripts/make-icon-resources.js, edits may be lost
*****************/`);

function iconsOfPpm(ppmFile, doExpandMask) {
  const toks = fs.readFileSync(ppmFile, 'utf8')
		  .split('\n')
		  .map(x => x.replace(/#.*/, ''))
		  .filter(x => x.match(/\S/) && !x.match("#"))
		  .join(' ').split(/\s+/)
		  .filter(x => x.match(/\S/));
  const nums = toks.map(x => parseInt(x));
  const width = nums[1];
  const height = nums[2];
  nums.splice(0,4); // P3 W H C
  const img = [];
  const mask = [];
  const ic8Bytes = [];
  const ic4Nybs = [];
  const ic1Bits = [];
  let expandMask = [];

  for (let x = 0; x < width; x++) {
	 for (let y = 0; y < height; y++) {
		const ix = y * width + x;
		img[ix] = [nums[ix * 3], nums[ix * 3+1], nums[ix*3+2]];
	 }
  }

  // cheating a bit with the color choices to match the icon as I've drawn it:
  palette.clut4[8] = [17*6, 17*9, 17*6];
  palette.clut4[9] = [11, 49, 10];

  img.forEach((pixel, ix) => {
	 // interpret cyan as transparent
	 if (pixel[0] == 0 && pixel[1] == 255 && pixel[2] == 255) {
		ic8Bytes.push(0);
		ic4Nybs.push(0);
		mask[ix] = 0;
	 }
	 else {
		ic8Bytes.push(palette.getIndex(pixel, palette.clut8));
		ic4Nybs.push(palette.getIndex(pixel, palette.clut4));
		mask[ix] = 1;
	 }
	 ic1Bits.push((pixel[0] + pixel[1] + pixel[2] > 3*128) ? 0 : 1);
  });

  function pixelAt(x, y) {
	 return (x >= 0 && x < width && y >= 0 && y < height) ? mask[width * y + x] : 0;
  }

  // expand mask by one pixel all around
  if (doExpandMask) {
	 for (let x = 0; x < width; x++) {
		for (let y = 0; y < height; y++) {
		  expandMask[width * y + x] = (pixelAt(x, y) || pixelAt(x+1,y) || pixelAt(x,y+1) || pixelAt(x-1,y) || pixelAt(x,y-1)) ? 1 : 0;
		}
	 }
  }
  else {
	 expandMask = mask;
  }

  return {
	 pixels:img, width, height, mask: expandMask, ic8Bytes, ic4Nybs, ic1Bits
  };
}

const iconSources = [
  {large: '/tmp/twelf-icon.ppm', small: '/tmp/twelf-icon-small.ppm', id: 128, tp: 'APPL', doExpandMask: true},
  {large: '/tmp/twelf-doc.ppm', small: '/tmp/twelf-doc-small.ppm', id: 129, tp: 'TEXT', doExpandMask: false},
]

function bytesOfBits(bits) {
  const bytes = [];
  for (let i = 0; i < bits.length / 8; i++) {
	 let b = 0;
	 for (let j = 0; j < 8; j++) {
		b = 2 * b + bits[i * 8 + j];
	 }
	 bytes.push(b);
  }
  return bytes;
}

function bytesOfNybbles(nybbles) {
  const bytes = [];
  for (let i = 0; i < nybbles.length / 2; i++) {
	 let b = 0;
	 for (let j = 0; j < 2; j++) {
		b = 16 * b + nybbles[i * 2 + j];
	 }
	 bytes.push(b);
  }
  return bytes;
}

function hexOfByte(x) {
  let s = x.toString(16);
  while (s.length < 2)
	 s = '0' + s;
  return s;
}

function rezOfBytes(bytes) {
  return bytes.map(x => {
	 const str = hexOfByte(x);
	 return `$"${str}"`
  }).join(" ");
}

console.log(`
resource 'BNDL' (128) {
  'TWLF', 0;
  {
    'FREF', { 0, 128, 1, 129 };
    'ICN#', { 0, 128, 1, 129 };
  }
};

resource 'FREF' (128) {
  'APPL', 0, "";
};

resource 'FREF' (129) {
  'TEXT', 1, "";
};
`);

iconSources.forEach(src => {
  const {large, small, id, doExpandMask} = src;
  const largeIcon = iconsOfPpm(large, doExpandMask);
  const smallIcon = iconsOfPpm(small, doExpandMask);

  console.log(`
resource 'ICN#' (${id}) {
  {
    ${rezOfBytes(bytesOfBits(largeIcon.ic1Bits))},
    ${rezOfBytes(bytesOfBits(largeIcon.mask))},
  }
};

resource 'ics#' (${id}) {
  {
    ${rezOfBytes(bytesOfBits(smallIcon.ic1Bits))},
    ${rezOfBytes(bytesOfBits(smallIcon.mask))},
  }
};

resource 'icl8' (${id}) {
  ${rezOfBytes(largeIcon.ic8Bytes)}
};

resource 'ics8' (${id}) {
  ${rezOfBytes(smallIcon.ic8Bytes)}
};

resource 'icl4' (${id}) {
  ${rezOfBytes(bytesOfNybbles(largeIcon.ic4Nybs))}
};

resource 'ics4' (${id}) {
  ${rezOfBytes(bytesOfNybbles(smallIcon.ic4Nybs))}
};

`);

});
